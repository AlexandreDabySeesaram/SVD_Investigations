{
  "hash": "f5fb919cb026548725474ab213b801a7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: SVD\nformat:\n  html:\n    code-fold: true\n    page-layout: full\n---\n\n\n\n\n\n# Import libraries\nStart by importing pytorch & matplotlib. I could not make the latex interpreter work in binder, so the corresponding lines are commented out. \n\n::: {#ed8e6d8f .cell execution_count=1}\n``` {.python .cell-code}\nimport torch \nimport matplotlib.pyplot as plt\n```\n:::\n\n\n# Create the functions\n\nThe separability proprieties of several functions are investigated. This code first shows the separability proprieties of different ways of clustering the 1D space into two regions. \nTwo types of functions are used to do so:\n* A sharp step function (Heaviside),\n* A smooth one (Tanh).\n\nIn both cases the position of the jump is parametrised by a scalar parameter $\\alpha$. \n\nFurhter investigations are conducted on moving front(s) with a \n* A gaussian function that is moving \n* Two gaussian functions moving at different rates\n\n::: {#5b2ca876 .cell execution_count=2}\n``` {.python .cell-code}\nL = 10                                      # Space domain\nAlpha_vect = torch.linspace(0,1,1500)       # vector of alphas\nx_vect = torch.linspace(0,L,2000)           # vector of x\n\n\nFunction = 'Heaviside'                      # Alpha-parameterised step function\nFunction = 'Tanh'                           # smooth alpha-parameterised step function\n# Function = 'Gauss'                        # Alpha-parameterised front function\nFunction = 'Gauss_sum'                      # Double alpha-parameterised front functions\n\n\n\n\nif Function == 'Heaviside':\n    F = torch.heaviside((x_vect[:,None] - (1-Alpha_vect[None,:])*L), x_vect[-1]/x_vect[-1])\nelif Function == 'Tanh':\n    F = torch.tanh((x_vect[:,None] - (1-Alpha_vect[None,:])*L))\nelif Function == 'Gauss':\n    F = torch.exp(-(x_vect[:,None] - (1-Alpha_vect[None,:])*L)**2)\n\nelif Function == 'Gauss_sum':\n    F = torch.exp(-(x_vect[:,None] - (1-Alpha_vect[None,:])*L)**2) + torch.exp(-(x_vect[:,None] - (1-2*Alpha_vect[None,:])*L)**2) \n```\n:::\n\n\n# Plot the reference function\n\n::: {#73388de6 .cell execution_count=3}\n``` {.python .cell-code}\nplt.imshow(F.t(),cmap='gray')\nplt.title('Full field')\nplt.xlabel('x')\nplt.ylabel('\\alpha')\n# plt.savefig('../Results/FullField_'+Function+'.pdf', transparent=True)  \nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/daby/anaconda3/lib/python3.11/site-packages/IPython/core/pylabtools.py:152: UserWarning:\n\nGlyph 7 (\u0007) missing from current font.\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](SVD_files/figure-html/cell-4-output-2.png){width=574 height=449}\n:::\n:::\n\n\n# Compute its SVD\n\n::: {#939a1d9a .cell execution_count=4}\n``` {.python .cell-code}\nU, S, V = torch.svd(F)\n```\n:::\n\n\n# Compute the truncated function\n\n::: {#5d4a8872 .cell execution_count=5}\n``` {.python .cell-code}\nN = 15                                                  # Number of modes kept for the truncation                   \n\nF_truncated = U[:,:N]@torch.diag(S[:N])@V[:,:N].t()     # Truncated function\n```\n:::\n\n\n# Plot the truncated function\n\n::: {#4983a0a8 .cell execution_count=6}\n``` {.python .cell-code}\nplt.imshow(F_truncated.t(),cmap='gray')\nplt.title(f'Truncated field, N={N}')\nplt.xlabel('x')\nplt.ylabel('alpha')\n# plt.savefig(f'../Results/TruncatedField_{N}_'+Function+'.pdf', transparent=True)  \nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](SVD_files/figure-html/cell-7-output-1.png){width=574 height=449}\n:::\n:::\n\n\n# Comparison\n\nThe truncated function and its reference are compared for two values\n* $\\alpha = 1/3$ &\n* $\\alpha = 2/3$.\n\n::: {#2dde78d9 .cell execution_count=7}\n``` {.python .cell-code}\nplt.plot(x_vect,F[:,1000],'k',label='Full, alpha = 2/3')\nplt.plot(x_vect,F_truncated[:,1000],'--',label='Truncated, alpha = 2/3')\nplt.plot(x_vect,F[:,500],'k',label='Full, alpha = 1/3')\nplt.plot(x_vect,F_truncated[:,500],'--',label='Truncated, alpha = 1/3')\nplt.legend(loc=\"upper left\")\nplt.title(f'2 slices of the field, N={N}')\nplt.xlabel('x')\nplt.ylabel('f(x,alpha)')\n# plt.savefig(f'../Results/Sliced_TruncatedField_{N}_'+Function+'.pdf', transparent=True)  \nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](SVD_files/figure-html/cell-8-output-1.png){width=589 height=449}\n:::\n:::\n\n\n# Interactive plot comparing the truncated function and the reference\n\nThis interactive plot allows to change the number of modes in the truncation and the value of the parameter $\\alpha$ .\n\n::: {#0004fce8 .cell execution_count=8}\n``` {.python .cell-code}\nplt.semilogy(S)\nplt.ylabel('sigma_i^2')\nplt.xlabel('Modes')\n# plt.savefig(f'../Results/SVD_Decay_'+Function+'.pdf', transparent=True)  \nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](SVD_files/figure-html/cell-9-output-1.png){width=599 height=431}\n:::\n:::\n\n\n",
    "supporting": [
      "SVD_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}